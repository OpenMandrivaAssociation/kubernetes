From 315276f5b20e16eda5ef6105f6338334799dd007 Mon Sep 17 00:00:00 2001
From: Jan Chaloupka <jchaloup@redhat.com>
Date: Wed, 23 Sep 2015 16:08:52 +0200
Subject: [PATCH] internal to inteernal

---
 .../src/github.com/gonum/graph/inteernal/linear.go |  73 ++++
 .../src/github.com/gonum/graph/inteernal/set.go    | 211 +++++++++++
 .../github.com/gonum/graph/inteernal/set_test.go   | 413 +++++++++++++++++++++
 .../src/github.com/gonum/graph/inteernal/sort.go   |  28 ++
 .../src/github.com/gonum/graph/internal/linear.go  |  73 ----
 .../src/github.com/gonum/graph/internal/set.go     | 211 -----------
 .../github.com/gonum/graph/internal/set_test.go    | 413 ---------------------
 .../src/github.com/gonum/graph/internal/sort.go    |  28 --
 .../github.com/gonum/graph/network/betweenness.go  |   2 +-
 .../src/github.com/gonum/graph/path/a_star.go      |   2 +-
 .../github.com/gonum/graph/path/control_flow.go    |   2 +-
 .../github.com/gonum/graph/path/dijkstra_test.go   |   2 +-
 .../gonum/graph/path/floydwarshall_test.go         |   2 +-
 .../gonum/graph/path/johnson_apsp_test.go          |   2 +-
 .../github.com/gonum/graph/path/spanning_tree.go   |   2 +-
 .../github.com/gonum/graph/topo/bron_kerbosch.go   |   2 +-
 .../gonum/graph/topo/bron_kerbosch_test.go         |   2 +-
 .../github.com/gonum/graph/topo/johnson_cycles.go  |   2 +-
 .../gonum/graph/topo/johnson_cycles_test.go        |   2 +-
 .../src/github.com/gonum/graph/topo/tarjan.go      |   2 +-
 .../src/github.com/gonum/graph/topo/tarjan_test.go |   2 +-
 .../src/github.com/gonum/graph/topo/topo_test.go   |   2 +-
 .../github.com/gonum/graph/traverse/traverse.go    |   2 +-
 .../gonum/graph/traverse/traverse_test.go          |   2 +-
 pkg/cmd/cli/describe/chaindescriber.go             |   2 +-
 25 files changed, 742 insertions(+), 742 deletions(-)
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
 create mode 100644 Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
 delete mode 100644 Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go

diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
new file mode 100644
index 0000000..3d64de9
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/linear.go
@@ -0,0 +1,73 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import (
+	"github.com/gonum/graph"
+)
+
+// NodeStack implements a LIFO stack of graph.Node.
+type NodeStack []graph.Node
+
+// Len returns the number of graph.Nodes on the stack.
+func (s *NodeStack) Len() int { return len(*s) }
+
+// Pop returns the last graph.Node on the stack and removes it
+// from the stack.
+func (s *NodeStack) Pop() graph.Node {
+	v := *s
+	v, n := v[:len(v)-1], v[len(v)-1]
+	*s = v
+	return n
+}
+
+// Push adds the node n to the stack at the last position.
+func (s *NodeStack) Push(n graph.Node) { *s = append(*s, n) }
+
+// NodeQueue implements a FIFO queue.
+type NodeQueue struct {
+	head int
+	data []graph.Node
+}
+
+// Len returns the number of graph.Nodes in the queue.
+func (q *NodeQueue) Len() int { return len(q.data) - q.head }
+
+// Enqueue adds the node n to the back of the queue.
+func (q *NodeQueue) Enqueue(n graph.Node) {
+	if len(q.data) == cap(q.data) && q.head > 0 {
+		l := q.Len()
+		copy(q.data, q.data[q.head:])
+		q.head = 0
+		q.data = append(q.data[:l], n)
+	} else {
+		q.data = append(q.data, n)
+	}
+}
+
+// Dequeue returns the graph.Node at the front of the queue and
+// removes it from the queue.
+func (q *NodeQueue) Dequeue() graph.Node {
+	if q.Len() == 0 {
+		panic("queue: empty queue")
+	}
+
+	var n graph.Node
+	n, q.data[q.head] = q.data[q.head], nil
+	q.head++
+
+	if q.Len() == 0 {
+		q.head = 0
+		q.data = q.data[:0]
+	}
+
+	return n
+}
+
+// Reset clears the queue for reuse.
+func (q *NodeQueue) Reset() {
+	q.head = 0
+	q.data = q.data[:0]
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
new file mode 100644
index 0000000..3ad1bc8
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set.go
@@ -0,0 +1,211 @@
+// Copyright ©2014 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import (
+	"unsafe"
+
+	"github.com/gonum/graph"
+)
+
+// IntSet is a set of integer identifiers.
+type IntSet map[int]struct{}
+
+// The simple accessor methods for Set are provided to allow ease of
+// implementation change should the need arise.
+
+// Add inserts an element into the set.
+func (s IntSet) Add(e int) {
+	s[e] = struct{}{}
+}
+
+// Has reports the existence of the element in the set.
+func (s IntSet) Has(e int) bool {
+	_, ok := s[e]
+	return ok
+}
+
+// Remove deletes the specified element from the set.
+func (s IntSet) Remove(e int) {
+	delete(s, e)
+}
+
+// Count reports the number of elements stored in the set.
+func (s IntSet) Count() int {
+	return len(s)
+}
+
+// Same determines whether two sets are backed by the same store. In the
+// current implementation using hash maps it makes use of the fact that
+// hash maps (at least in the gc implementation) are passed as a pointer
+// to a runtime Hmap struct.
+//
+// A map is not seen by the runtime as a pointer though, so we cannot
+// directly compare the sets converted to unsafe.Pointer and need to take
+// the sets' addressed and dereference them as pointers to some comparable
+// type.
+func Same(s1, s2 Set) bool {
+	return *(*uintptr)(unsafe.Pointer(&s1)) == *(*uintptr)(unsafe.Pointer(&s2))
+}
+
+// A set is a set of nodes keyed in their integer identifiers.
+type Set map[int]graph.Node
+
+// The simple accessor methods for Set are provided to allow ease of
+// implementation change should the need arise.
+
+// Add inserts an element into the set.
+func (s Set) Add(n graph.Node) {
+	s[n.ID()] = n
+}
+
+// Remove deletes the specified element from the set.
+func (s Set) Remove(e graph.Node) {
+	delete(s, e.ID())
+}
+
+// Has reports the existence of the element in the set.
+func (s Set) Has(n graph.Node) bool {
+	_, ok := s[n.ID()]
+	return ok
+}
+
+// Clear returns an empty set, possibly using the same backing store.
+// Clear is not provided as a method since there is no way to replace
+// the calling value if clearing is performed by a make(set). Clear
+// should never be called without keeping the returned value.
+func Clear(s Set) Set {
+	if len(s) == 0 {
+		return s
+	}
+
+	return make(Set)
+}
+
+// Copy performs a perfect copy from s1 to dst (meaning the sets will
+// be equal).
+func (dst Set) Copy(src Set) Set {
+	if Same(src, dst) {
+		return dst
+	}
+
+	if len(dst) > 0 {
+		dst = make(Set, len(src))
+	}
+
+	for e, n := range src {
+		dst[e] = n
+	}
+
+	return dst
+}
+
+// Equal reports set equality between the parameters. Sets are equal if
+// and only if they have the same elements.
+func Equal(s1, s2 Set) bool {
+	if Same(s1, s2) {
+		return true
+	}
+
+	if len(s1) != len(s2) {
+		return false
+	}
+
+	for e := range s1 {
+		if _, ok := s2[e]; !ok {
+			return false
+		}
+	}
+
+	return true
+}
+
+// Union takes the union of s1 and s2, and stores it in dst.
+//
+// The union of two sets, s1 and s2, is the set containing all the
+// elements of each, for instance:
+//
+//     {a,b,c} UNION {d,e,f} = {a,b,c,d,e,f}
+//
+// Since sets may not have repetition, unions of two sets that overlap
+// do not contain repeat elements, that is:
+//
+//     {a,b,c} UNION {b,c,d} = {a,b,c,d}
+//
+func (dst Set) Union(s1, s2 Set) Set {
+	if Same(s1, s2) {
+		return dst.Copy(s1)
+	}
+
+	if !Same(s1, dst) && !Same(s2, dst) {
+		dst = Clear(dst)
+	}
+
+	if !Same(dst, s1) {
+		for e, n := range s1 {
+			dst[e] = n
+		}
+	}
+
+	if !Same(dst, s2) {
+		for e, n := range s2 {
+			dst[e] = n
+		}
+	}
+
+	return dst
+}
+
+// Intersect takes the intersection of s1 and s2, and stores it in dst.
+//
+// The intersection of two sets, s1 and s2, is the set containing all
+// the elements shared between the two sets, for instance:
+//
+//     {a,b,c} INTERSECT {b,c,d} = {b,c}
+//
+// The intersection between a set and itself is itself, and thus
+// effectively a copy operation:
+//
+//     {a,b,c} INTERSECT {a,b,c} = {a,b,c}
+//
+// The intersection between two sets that share no elements is the empty
+// set:
+//
+//     {a,b,c} INTERSECT {d,e,f} = {}
+//
+func (dst Set) Intersect(s1, s2 Set) Set {
+	var swap Set
+
+	if Same(s1, s2) {
+		return dst.Copy(s1)
+	}
+	if Same(s1, dst) {
+		swap = s2
+	} else if Same(s2, dst) {
+		swap = s1
+	} else {
+		dst = Clear(dst)
+
+		if len(s1) > len(s2) {
+			s1, s2 = s2, s1
+		}
+
+		for e, n := range s1 {
+			if _, ok := s2[e]; ok {
+				dst[e] = n
+			}
+		}
+
+		return dst
+	}
+
+	for e := range dst {
+		if _, ok := swap[e]; !ok {
+			delete(dst, e)
+		}
+	}
+
+	return dst
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
new file mode 100644
index 0000000..fb39620
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/set_test.go
@@ -0,0 +1,413 @@
+// Copyright ©2014 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+import "testing"
+
+type node int
+
+func (n node) ID() int { return int(n) }
+
+// count reports the number of elements stored in the set.
+func (s Set) count() int {
+	return len(s)
+}
+
+// TestSame tests the assumption that pointer equality via unsafe conversion
+// of a map[int]struct{} to uintptr is a valid test for perfect identity between
+// set values. If any of the tests in TestSame fail, the package is broken and same
+// must be reimplemented to conform to the runtime map implementation. The relevant
+// code to look at (at least for gc) is in runtime/hashmap.{h,goc}.
+func TestSame(t *testing.T) {
+	var (
+		a = make(Set)
+		b = make(Set)
+		c = a
+	)
+
+	if Same(a, b) {
+		t.Error("Independently created sets test as same")
+	}
+	if !Same(a, c) {
+		t.Error("Set copy and original test as not same.")
+	}
+	a.Add(node(1))
+	if !Same(a, c) {
+		t.Error("Set copy and original test as not same after addition.")
+	}
+	if !Same(nil, nil) {
+		t.Error("nil sets test as not same.")
+	}
+	if Same(b, nil) {
+		t.Error("nil and empty sets test as same.")
+	}
+}
+
+func TestAdd(t *testing.T) {
+	s := make(Set)
+	if s == nil {
+		t.Fatal("Set cannot be created successfully")
+	}
+
+	if s.count() != 0 {
+		t.Error("Set somehow contains new elements upon creation")
+	}
+
+	s.Add(node(1))
+	s.Add(node(3))
+	s.Add(node(5))
+
+	if s.count() != 3 {
+		t.Error("Incorrect number of set elements after adding")
+	}
+
+	if !s.Has(node(1)) || !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set doesn't contain element that was added")
+	}
+
+	s.Add(node(1))
+
+	if s.count() > 3 {
+		t.Error("Set double-adds element (element not unique)")
+	} else if s.count() < 3 {
+		t.Error("Set double-add lowered len")
+	}
+
+	if !s.Has(node(1)) {
+		t.Error("Set doesn't contain double-added element")
+	}
+
+	if !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set removes element on double-add")
+	}
+
+	for e, n := range s {
+		if e != n.ID() {
+			t.Error("Element ID did not match key: %d != %d", e, n.ID())
+		}
+	}
+}
+
+func TestRemove(t *testing.T) {
+	s := make(Set)
+
+	s.Add(node(1))
+	s.Add(node(3))
+	s.Add(node(5))
+
+	s.Remove(node(1))
+
+	if s.count() != 2 {
+		t.Error("Incorrect number of set elements after removing an element")
+	}
+
+	if s.Has(node(1)) {
+		t.Error("Element present after removal")
+	}
+
+	if !s.Has(node(3)) || !s.Has(node(5)) {
+		t.Error("Set remove removed wrong element")
+	}
+
+	s.Remove(node(1))
+
+	if s.count() != 2 || s.Has(node(1)) {
+		t.Error("Double set remove does something strange")
+	}
+
+	s.Add(node(1))
+
+	if s.count() != 3 || !s.Has(node(1)) {
+		t.Error("Cannot add element after removal")
+	}
+}
+
+func TestClear(t *testing.T) {
+	s := make(Set)
+
+	s.Add(node(8))
+	s.Add(node(9))
+	s.Add(node(10))
+
+	s = Clear(s)
+
+	if s.count() != 0 {
+		t.Error("Clear did not properly reset set to size 0")
+	}
+}
+
+func TestSelfEqual(t *testing.T) {
+	s := make(Set)
+
+	if !Equal(s, s) {
+		t.Error("Set is not equal to itself")
+	}
+
+	s.Add(node(1))
+
+	if !Equal(s, s) {
+		t.Error("Set ceases self equality after adding element")
+	}
+}
+
+func TestEqual(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+
+	if !Equal(s1, s2) {
+		t.Error("Two different empty sets not equal")
+	}
+
+	s1.Add(node(1))
+	if Equal(s1, s2) {
+		t.Error("Two different sets with different elements not equal")
+	}
+
+	s2.Add(node(1))
+	if !Equal(s1, s2) {
+		t.Error("Two sets with same element not equal")
+	}
+}
+
+func TestCopy(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Copy(s1)
+
+	if !Equal(s1, s2) {
+		t.Fatalf("Two sets not equal after copy")
+	}
+
+	s2.Remove(node(1))
+
+	if Equal(s1, s2) {
+		t.Errorf("Mutating one set mutated another after copy")
+	}
+}
+
+func TestSelfCopy(t *testing.T) {
+	s1 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s1.Copy(s1)
+
+	if s1.count() != 2 {
+		t.Error("Something strange happened when copying into self")
+	}
+}
+
+func TestUnionSame(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(1))
+	s2.Add(node(2))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 2 {
+		t.Error("Union of same sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) {
+		t.Error("Union of same sets yields wrong elements")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestUnionDiff(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(3))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 3 {
+		t.Error("Union of different sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Union of different sets yields set with wrong elements")
+	}
+
+	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 1)")
+	}
+
+	if !s2.Has(node(3)) || s2.Has(node(1)) || s2.Has(node(2)) || s2.count() != 1 {
+		t.Error("Union of sets mutates non-destination set (argument 2)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestUnionOverlapping(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(1))
+	s1.Add(node(2))
+
+	s2.Add(node(2))
+	s2.Add(node(3))
+
+	s3.Union(s1, s2)
+
+	if s3.count() != 3 {
+		t.Error("Union of overlapping sets yields set with wrong len")
+	}
+
+	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Union of overlapping sets yields set with wrong elements")
+	}
+
+	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 1)")
+	}
+
+	if !s2.Has(node(3)) || s2.Has(node(1)) || !s2.Has(node(2)) || s2.count() != 2 {
+		t.Error("Union of sets mutates non-destination set (argument 2)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectSame(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(2))
+	s2.Add(node(3))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 2 {
+		t.Errorf("Intersection of identical sets yields set of wrong len %d", card)
+	}
+
+	if !s3.Has(node(2)) || !s3.Has(node(3)) {
+		t.Error("Intersection of identical sets yields set of wrong elements")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectDiff(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(1))
+	s2.Add(node(4))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 0 {
+		t.Errorf("Intersection of different yields non-empty set %d", card)
+	}
+
+	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(1)) || s1.Has(node(4)) || s1.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	if s2.Has(node(2)) || s2.Has(node(3)) || !s2.Has(node(1)) || !s2.Has(node(4)) || s2.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
+
+func TestIntersectOverlapping(t *testing.T) {
+	s1 := make(Set)
+	s2 := make(Set)
+	s3 := make(Set)
+
+	s1.Add(node(2))
+	s1.Add(node(3))
+
+	s2.Add(node(3))
+	s2.Add(node(4))
+
+	s3.Intersect(s1, s2)
+
+	if card := s3.count(); card != 1 {
+		t.Errorf("Intersection of overlapping sets yields set of incorrect len %d", card)
+	}
+
+	if !s3.Has(node(3)) {
+		t.Errorf("Intersection of overlapping sets yields set with wrong element")
+	}
+
+	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(4)) || s1.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	if s2.Has(node(2)) || !s2.Has(node(3)) || !s2.Has(node(4)) || s2.count() != 2 {
+		t.Error("Intersection of sets mutates non-destination set (argument 1)")
+	}
+
+	for i, s := range []Set{s1, s2, s3} {
+		for e, n := range s {
+			if e != n.ID() {
+				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
+			}
+		}
+	}
+}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
new file mode 100644
index 0000000..3bfee0f
--- /dev/null
+++ b/Godeps/_workspace/src/github.com/gonum/graph/inteernal/sort.go
@@ -0,0 +1,28 @@
+// Copyright ©2015 The gonum Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package internal
+
+// BySliceValues implements the sort.Interface sorting a slice of
+// []int lexically by the values of the []int.
+type BySliceValues [][]int
+
+func (c BySliceValues) Len() int { return len(c) }
+func (c BySliceValues) Less(i, j int) bool {
+	a, b := c[i], c[j]
+	l := len(a)
+	if len(b) < l {
+		l = len(b)
+	}
+	for k, v := range a[:l] {
+		if v < b[k] {
+			return true
+		}
+		if v > b[k] {
+			return false
+		}
+	}
+	return len(a) < len(b)
+}
+func (c BySliceValues) Swap(i, j int) { c[i], c[j] = c[j], c[i] }
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
deleted file mode 100644
index 3d64de9..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/linear.go
+++ /dev/null
@@ -1,73 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import (
-	"github.com/gonum/graph"
-)
-
-// NodeStack implements a LIFO stack of graph.Node.
-type NodeStack []graph.Node
-
-// Len returns the number of graph.Nodes on the stack.
-func (s *NodeStack) Len() int { return len(*s) }
-
-// Pop returns the last graph.Node on the stack and removes it
-// from the stack.
-func (s *NodeStack) Pop() graph.Node {
-	v := *s
-	v, n := v[:len(v)-1], v[len(v)-1]
-	*s = v
-	return n
-}
-
-// Push adds the node n to the stack at the last position.
-func (s *NodeStack) Push(n graph.Node) { *s = append(*s, n) }
-
-// NodeQueue implements a FIFO queue.
-type NodeQueue struct {
-	head int
-	data []graph.Node
-}
-
-// Len returns the number of graph.Nodes in the queue.
-func (q *NodeQueue) Len() int { return len(q.data) - q.head }
-
-// Enqueue adds the node n to the back of the queue.
-func (q *NodeQueue) Enqueue(n graph.Node) {
-	if len(q.data) == cap(q.data) && q.head > 0 {
-		l := q.Len()
-		copy(q.data, q.data[q.head:])
-		q.head = 0
-		q.data = append(q.data[:l], n)
-	} else {
-		q.data = append(q.data, n)
-	}
-}
-
-// Dequeue returns the graph.Node at the front of the queue and
-// removes it from the queue.
-func (q *NodeQueue) Dequeue() graph.Node {
-	if q.Len() == 0 {
-		panic("queue: empty queue")
-	}
-
-	var n graph.Node
-	n, q.data[q.head] = q.data[q.head], nil
-	q.head++
-
-	if q.Len() == 0 {
-		q.head = 0
-		q.data = q.data[:0]
-	}
-
-	return n
-}
-
-// Reset clears the queue for reuse.
-func (q *NodeQueue) Reset() {
-	q.head = 0
-	q.data = q.data[:0]
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
deleted file mode 100644
index 3ad1bc8..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/set.go
+++ /dev/null
@@ -1,211 +0,0 @@
-// Copyright ©2014 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import (
-	"unsafe"
-
-	"github.com/gonum/graph"
-)
-
-// IntSet is a set of integer identifiers.
-type IntSet map[int]struct{}
-
-// The simple accessor methods for Set are provided to allow ease of
-// implementation change should the need arise.
-
-// Add inserts an element into the set.
-func (s IntSet) Add(e int) {
-	s[e] = struct{}{}
-}
-
-// Has reports the existence of the element in the set.
-func (s IntSet) Has(e int) bool {
-	_, ok := s[e]
-	return ok
-}
-
-// Remove deletes the specified element from the set.
-func (s IntSet) Remove(e int) {
-	delete(s, e)
-}
-
-// Count reports the number of elements stored in the set.
-func (s IntSet) Count() int {
-	return len(s)
-}
-
-// Same determines whether two sets are backed by the same store. In the
-// current implementation using hash maps it makes use of the fact that
-// hash maps (at least in the gc implementation) are passed as a pointer
-// to a runtime Hmap struct.
-//
-// A map is not seen by the runtime as a pointer though, so we cannot
-// directly compare the sets converted to unsafe.Pointer and need to take
-// the sets' addressed and dereference them as pointers to some comparable
-// type.
-func Same(s1, s2 Set) bool {
-	return *(*uintptr)(unsafe.Pointer(&s1)) == *(*uintptr)(unsafe.Pointer(&s2))
-}
-
-// A set is a set of nodes keyed in their integer identifiers.
-type Set map[int]graph.Node
-
-// The simple accessor methods for Set are provided to allow ease of
-// implementation change should the need arise.
-
-// Add inserts an element into the set.
-func (s Set) Add(n graph.Node) {
-	s[n.ID()] = n
-}
-
-// Remove deletes the specified element from the set.
-func (s Set) Remove(e graph.Node) {
-	delete(s, e.ID())
-}
-
-// Has reports the existence of the element in the set.
-func (s Set) Has(n graph.Node) bool {
-	_, ok := s[n.ID()]
-	return ok
-}
-
-// Clear returns an empty set, possibly using the same backing store.
-// Clear is not provided as a method since there is no way to replace
-// the calling value if clearing is performed by a make(set). Clear
-// should never be called without keeping the returned value.
-func Clear(s Set) Set {
-	if len(s) == 0 {
-		return s
-	}
-
-	return make(Set)
-}
-
-// Copy performs a perfect copy from s1 to dst (meaning the sets will
-// be equal).
-func (dst Set) Copy(src Set) Set {
-	if Same(src, dst) {
-		return dst
-	}
-
-	if len(dst) > 0 {
-		dst = make(Set, len(src))
-	}
-
-	for e, n := range src {
-		dst[e] = n
-	}
-
-	return dst
-}
-
-// Equal reports set equality between the parameters. Sets are equal if
-// and only if they have the same elements.
-func Equal(s1, s2 Set) bool {
-	if Same(s1, s2) {
-		return true
-	}
-
-	if len(s1) != len(s2) {
-		return false
-	}
-
-	for e := range s1 {
-		if _, ok := s2[e]; !ok {
-			return false
-		}
-	}
-
-	return true
-}
-
-// Union takes the union of s1 and s2, and stores it in dst.
-//
-// The union of two sets, s1 and s2, is the set containing all the
-// elements of each, for instance:
-//
-//     {a,b,c} UNION {d,e,f} = {a,b,c,d,e,f}
-//
-// Since sets may not have repetition, unions of two sets that overlap
-// do not contain repeat elements, that is:
-//
-//     {a,b,c} UNION {b,c,d} = {a,b,c,d}
-//
-func (dst Set) Union(s1, s2 Set) Set {
-	if Same(s1, s2) {
-		return dst.Copy(s1)
-	}
-
-	if !Same(s1, dst) && !Same(s2, dst) {
-		dst = Clear(dst)
-	}
-
-	if !Same(dst, s1) {
-		for e, n := range s1 {
-			dst[e] = n
-		}
-	}
-
-	if !Same(dst, s2) {
-		for e, n := range s2 {
-			dst[e] = n
-		}
-	}
-
-	return dst
-}
-
-// Intersect takes the intersection of s1 and s2, and stores it in dst.
-//
-// The intersection of two sets, s1 and s2, is the set containing all
-// the elements shared between the two sets, for instance:
-//
-//     {a,b,c} INTERSECT {b,c,d} = {b,c}
-//
-// The intersection between a set and itself is itself, and thus
-// effectively a copy operation:
-//
-//     {a,b,c} INTERSECT {a,b,c} = {a,b,c}
-//
-// The intersection between two sets that share no elements is the empty
-// set:
-//
-//     {a,b,c} INTERSECT {d,e,f} = {}
-//
-func (dst Set) Intersect(s1, s2 Set) Set {
-	var swap Set
-
-	if Same(s1, s2) {
-		return dst.Copy(s1)
-	}
-	if Same(s1, dst) {
-		swap = s2
-	} else if Same(s2, dst) {
-		swap = s1
-	} else {
-		dst = Clear(dst)
-
-		if len(s1) > len(s2) {
-			s1, s2 = s2, s1
-		}
-
-		for e, n := range s1 {
-			if _, ok := s2[e]; ok {
-				dst[e] = n
-			}
-		}
-
-		return dst
-	}
-
-	for e := range dst {
-		if _, ok := swap[e]; !ok {
-			delete(dst, e)
-		}
-	}
-
-	return dst
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
deleted file mode 100644
index fb39620..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/set_test.go
+++ /dev/null
@@ -1,413 +0,0 @@
-// Copyright ©2014 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-import "testing"
-
-type node int
-
-func (n node) ID() int { return int(n) }
-
-// count reports the number of elements stored in the set.
-func (s Set) count() int {
-	return len(s)
-}
-
-// TestSame tests the assumption that pointer equality via unsafe conversion
-// of a map[int]struct{} to uintptr is a valid test for perfect identity between
-// set values. If any of the tests in TestSame fail, the package is broken and same
-// must be reimplemented to conform to the runtime map implementation. The relevant
-// code to look at (at least for gc) is in runtime/hashmap.{h,goc}.
-func TestSame(t *testing.T) {
-	var (
-		a = make(Set)
-		b = make(Set)
-		c = a
-	)
-
-	if Same(a, b) {
-		t.Error("Independently created sets test as same")
-	}
-	if !Same(a, c) {
-		t.Error("Set copy and original test as not same.")
-	}
-	a.Add(node(1))
-	if !Same(a, c) {
-		t.Error("Set copy and original test as not same after addition.")
-	}
-	if !Same(nil, nil) {
-		t.Error("nil sets test as not same.")
-	}
-	if Same(b, nil) {
-		t.Error("nil and empty sets test as same.")
-	}
-}
-
-func TestAdd(t *testing.T) {
-	s := make(Set)
-	if s == nil {
-		t.Fatal("Set cannot be created successfully")
-	}
-
-	if s.count() != 0 {
-		t.Error("Set somehow contains new elements upon creation")
-	}
-
-	s.Add(node(1))
-	s.Add(node(3))
-	s.Add(node(5))
-
-	if s.count() != 3 {
-		t.Error("Incorrect number of set elements after adding")
-	}
-
-	if !s.Has(node(1)) || !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set doesn't contain element that was added")
-	}
-
-	s.Add(node(1))
-
-	if s.count() > 3 {
-		t.Error("Set double-adds element (element not unique)")
-	} else if s.count() < 3 {
-		t.Error("Set double-add lowered len")
-	}
-
-	if !s.Has(node(1)) {
-		t.Error("Set doesn't contain double-added element")
-	}
-
-	if !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set removes element on double-add")
-	}
-
-	for e, n := range s {
-		if e != n.ID() {
-			t.Error("Element ID did not match key: %d != %d", e, n.ID())
-		}
-	}
-}
-
-func TestRemove(t *testing.T) {
-	s := make(Set)
-
-	s.Add(node(1))
-	s.Add(node(3))
-	s.Add(node(5))
-
-	s.Remove(node(1))
-
-	if s.count() != 2 {
-		t.Error("Incorrect number of set elements after removing an element")
-	}
-
-	if s.Has(node(1)) {
-		t.Error("Element present after removal")
-	}
-
-	if !s.Has(node(3)) || !s.Has(node(5)) {
-		t.Error("Set remove removed wrong element")
-	}
-
-	s.Remove(node(1))
-
-	if s.count() != 2 || s.Has(node(1)) {
-		t.Error("Double set remove does something strange")
-	}
-
-	s.Add(node(1))
-
-	if s.count() != 3 || !s.Has(node(1)) {
-		t.Error("Cannot add element after removal")
-	}
-}
-
-func TestClear(t *testing.T) {
-	s := make(Set)
-
-	s.Add(node(8))
-	s.Add(node(9))
-	s.Add(node(10))
-
-	s = Clear(s)
-
-	if s.count() != 0 {
-		t.Error("Clear did not properly reset set to size 0")
-	}
-}
-
-func TestSelfEqual(t *testing.T) {
-	s := make(Set)
-
-	if !Equal(s, s) {
-		t.Error("Set is not equal to itself")
-	}
-
-	s.Add(node(1))
-
-	if !Equal(s, s) {
-		t.Error("Set ceases self equality after adding element")
-	}
-}
-
-func TestEqual(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-
-	if !Equal(s1, s2) {
-		t.Error("Two different empty sets not equal")
-	}
-
-	s1.Add(node(1))
-	if Equal(s1, s2) {
-		t.Error("Two different sets with different elements not equal")
-	}
-
-	s2.Add(node(1))
-	if !Equal(s1, s2) {
-		t.Error("Two sets with same element not equal")
-	}
-}
-
-func TestCopy(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Copy(s1)
-
-	if !Equal(s1, s2) {
-		t.Fatalf("Two sets not equal after copy")
-	}
-
-	s2.Remove(node(1))
-
-	if Equal(s1, s2) {
-		t.Errorf("Mutating one set mutated another after copy")
-	}
-}
-
-func TestSelfCopy(t *testing.T) {
-	s1 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s1.Copy(s1)
-
-	if s1.count() != 2 {
-		t.Error("Something strange happened when copying into self")
-	}
-}
-
-func TestUnionSame(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(1))
-	s2.Add(node(2))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 2 {
-		t.Error("Union of same sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) {
-		t.Error("Union of same sets yields wrong elements")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestUnionDiff(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(3))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 3 {
-		t.Error("Union of different sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Union of different sets yields set with wrong elements")
-	}
-
-	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 1)")
-	}
-
-	if !s2.Has(node(3)) || s2.Has(node(1)) || s2.Has(node(2)) || s2.count() != 1 {
-		t.Error("Union of sets mutates non-destination set (argument 2)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestUnionOverlapping(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(1))
-	s1.Add(node(2))
-
-	s2.Add(node(2))
-	s2.Add(node(3))
-
-	s3.Union(s1, s2)
-
-	if s3.count() != 3 {
-		t.Error("Union of overlapping sets yields set with wrong len")
-	}
-
-	if !s3.Has(node(1)) || !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Union of overlapping sets yields set with wrong elements")
-	}
-
-	if s1.Has(node(3)) || !s1.Has(node(2)) || !s1.Has(node(1)) || s1.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 1)")
-	}
-
-	if !s2.Has(node(3)) || s2.Has(node(1)) || !s2.Has(node(2)) || s2.count() != 2 {
-		t.Error("Union of sets mutates non-destination set (argument 2)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectSame(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(2))
-	s2.Add(node(3))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 2 {
-		t.Errorf("Intersection of identical sets yields set of wrong len %d", card)
-	}
-
-	if !s3.Has(node(2)) || !s3.Has(node(3)) {
-		t.Error("Intersection of identical sets yields set of wrong elements")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectDiff(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(1))
-	s2.Add(node(4))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 0 {
-		t.Errorf("Intersection of different yields non-empty set %d", card)
-	}
-
-	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(1)) || s1.Has(node(4)) || s1.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	if s2.Has(node(2)) || s2.Has(node(3)) || !s2.Has(node(1)) || !s2.Has(node(4)) || s2.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
-
-func TestIntersectOverlapping(t *testing.T) {
-	s1 := make(Set)
-	s2 := make(Set)
-	s3 := make(Set)
-
-	s1.Add(node(2))
-	s1.Add(node(3))
-
-	s2.Add(node(3))
-	s2.Add(node(4))
-
-	s3.Intersect(s1, s2)
-
-	if card := s3.count(); card != 1 {
-		t.Errorf("Intersection of overlapping sets yields set of incorrect len %d", card)
-	}
-
-	if !s3.Has(node(3)) {
-		t.Errorf("Intersection of overlapping sets yields set with wrong element")
-	}
-
-	if !s1.Has(node(2)) || !s1.Has(node(3)) || s1.Has(node(4)) || s1.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	if s2.Has(node(2)) || !s2.Has(node(3)) || !s2.Has(node(4)) || s2.count() != 2 {
-		t.Error("Intersection of sets mutates non-destination set (argument 1)")
-	}
-
-	for i, s := range []Set{s1, s2, s3} {
-		for e, n := range s {
-			if e != n.ID() {
-				t.Error("Element ID did not match key in s%d: %d != %d", i+1, e, n.ID())
-			}
-		}
-	}
-}
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go b/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go
deleted file mode 100644
index 3bfee0f..0000000
--- a/Godeps/_workspace/src/github.com/gonum/graph/internal/sort.go
+++ /dev/null
@@ -1,28 +0,0 @@
-// Copyright ©2015 The gonum Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style
-// license that can be found in the LICENSE file.
-
-package internal
-
-// BySliceValues implements the sort.Interface sorting a slice of
-// []int lexically by the values of the []int.
-type BySliceValues [][]int
-
-func (c BySliceValues) Len() int { return len(c) }
-func (c BySliceValues) Less(i, j int) bool {
-	a, b := c[i], c[j]
-	l := len(a)
-	if len(b) < l {
-		l = len(b)
-	}
-	for k, v := range a[:l] {
-		if v < b[k] {
-			return true
-		}
-		if v > b[k] {
-			return false
-		}
-	}
-	return len(a) < len(b)
-}
-func (c BySliceValues) Swap(i, j int) { c[i], c[j] = c[j], c[i] }
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go b/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
index ad16732..dbe216e 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/network/betweenness.go
@@ -8,7 +8,7 @@ import (
 	"math"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go b/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
index b41d194..d742cff 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/a_star.go
@@ -8,7 +8,7 @@ import (
 	"container/heap"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // Heuristic returns an estimate of the cost of travelling between two nodes.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go b/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
index 219226d..9bebf2c 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/control_flow.go
@@ -6,7 +6,7 @@ package path
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // PostDominatores returns all dominators for all nodes in g. It does not
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
index c22d28f..0526ba9 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/dijkstra_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
index ea78e79..d23bb6a 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/floydwarshall_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go b/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
index 814000f..588581d 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/johnson_apsp_test.go
@@ -11,7 +11,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go b/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
index 99b30cb..2e3a501 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/path/spanning_tree.go
@@ -9,7 +9,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // EdgeListerGraph is an undirected graph than returns its complete set of edges.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
index 5e30d5b..a012b9b 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch.go
@@ -6,7 +6,7 @@ package topo
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // VertexOrdering returns the vertex ordering and the k-cores of
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
index 3d22c36..73e303c 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/bron_kerbosch_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
index 36d4cbd..ce9318e 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles.go
@@ -8,7 +8,7 @@ import (
 	"sort"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // johnson implements Johnson's "Finding all the elementary
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
index a1ee6e1..149fff2 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/johnson_cycles_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
index 908358c..f779bbb 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan.go
@@ -9,7 +9,7 @@ import (
 	"sort"
 
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // Unorderable is an error containing sets of unorderable graph.Nodes.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
index 504633f..63c1a82 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/tarjan_test.go
@@ -10,7 +10,7 @@ import (
 	"testing"
 
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go b/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
index d903ee1..d71b788 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/topo/topo_test.go
@@ -11,7 +11,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/topo"
 )
 
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
index bb0fdad..a7eb54d 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse.go
@@ -7,7 +7,7 @@ package traverse
 
 import (
 	"github.com/gonum/graph"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 )
 
 // BreadthFirst implements stateful breadth-first graph traversal.
diff --git a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
index c5a4e2a..b771b46 100644
--- a/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
+++ b/Godeps/_workspace/src/github.com/gonum/graph/traverse/traverse_test.go
@@ -12,7 +12,7 @@ import (
 
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/concrete"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/traverse"
 )
 
diff --git a/pkg/cmd/cli/describe/chaindescriber.go b/pkg/cmd/cli/describe/chaindescriber.go
index 92b1328..4715e6b 100644
--- a/pkg/cmd/cli/describe/chaindescriber.go
+++ b/pkg/cmd/cli/describe/chaindescriber.go
@@ -8,7 +8,7 @@ import (
 	"github.com/golang/glog"
 	"github.com/gonum/graph"
 	"github.com/gonum/graph/encoding/dot"
-	"github.com/gonum/graph/internal"
+	"github.com/gonum/graph/inteernal"
 	"github.com/gonum/graph/path"
 	kapi "k8s.io/kubernetes/pkg/api"
 	kutil "k8s.io/kubernetes/pkg/util"
-- 
1.9.3

